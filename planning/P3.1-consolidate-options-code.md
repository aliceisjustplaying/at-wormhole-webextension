# P3.1: Consolidate Options Code

**Created**: 2025-06-15
**Status**: Completed
**Priority**: Medium (Code Quality)
**Completed**: 2025-06-15

## Problem Description

The options module exists (`src/shared/options.ts`) but is underutilized, leading to:

- Duplicate getter functions in popup.ts: `getShowEmojis()` and `getStrictMode()`
- Options page not using the shared module
- Inconsistent option access patterns across files
- The shared module uses a single storage key approach that differs from individual key storage in other files

### Current Issues

1. **Duplicate Getters in popup.ts**:

   ```typescript
   // popup.ts:66-78
   async function getShowEmojis(): Promise<boolean> {
     const result = await chrome.storage.sync.get({ showEmojis: true });
     return result.showEmojis;
   }

   async function getStrictMode(): Promise<boolean> {
     const result = await chrome.storage.sync.get({ strictMode: false });
     return result.strictMode;
   }
   ```

2. **Similar Logic in options.ts**:

   ```typescript
   // options.ts:23-37
   const result = await chrome.storage.sync.get({
     showEmojis: true,
     strictMode: false,
   });
   ```

3. **Inconsistent Storage Patterns**:
   - Shared module uses single key: `chrome.storage.sync.get('wormhole-options')`
   - Other files use individual keys: `chrome.storage.sync.get({ showEmojis: true })`
   - This creates potential synchronization issues

## Root Cause Analysis

1. The shared options module exists but isn't used consistently
2. Different storage patterns between the shared module and other files
3. The shared module has caching but other files don't leverage it
4. No neverthrow integration in the existing options module

## Solution Approach

### Rewrite the Options Module

1. **Rewrite**: `src/shared/options.ts`

   - Add neverthrow error handling
   - Switch to individual key storage (matching popup/options usage)
   - Remove single-key storage pattern completely
   - Add getter functions for individual options
   - Add setter functions
   - Add change event subscriptions
   - Remove old caching approach

2. **Option Configuration Structure**:

   ```typescript
   interface OptionConfig<T> {
     key: string;
     defaultValue: T;
     description: string;
   }

   const OPTIONS = {
     showEmojis: {
       key: 'showEmojis',
       defaultValue: true,
       description: 'Show emoji icons in service lists',
     },
     strictMode: {
       key: 'strictMode',
       defaultValue: false,
       description: 'Only show services that support the current content type',
     },
   } as const;
   ```

3. **Centralized API**:
   - `getOption(optionName)`: Get single option value
   - `getOptions()`: Get all options
   - `setOption(optionName, value)`: Set single option
   - `setOptions(options)`: Set multiple options
   - `onOptionsChange(callback)`: Subscribe to changes
   - `getDefaults()`: Get all default values

## Implementation Plan

### Step 1: Rewrite the Options Module

1. Rewrite `src/shared/options.ts` to:
   - Use individual-key storage pattern
   - Add neverthrow integration throughout
   - Provide typed getter/setter functions
   - Add change event handling
   - Remove old single-key pattern
   - Simplify caching approach

### Step 2: Update Popup Module

1. Remove duplicate option functions
2. Import from shared options module
3. Update option access to use new API
4. Maintain existing functionality

### Step 3: Update Options Page

1. Remove hardcoded defaults
2. Import from shared options module
3. Use centralized getters/setters
4. Update initialization logic

### Step 4: Update Service Worker

1. Import options module if needed
2. Ensure consistent option access
3. Handle any edge cases

### Step 5: Add Tests

1. Test default values
2. Test getter/setter functions
3. Test change events
4. Test error handling

## Affected Files

- `src/shared/options.ts` - Enhance existing module
- `src/popup/popup.ts` - Remove duplicate functions
- `src/options/options.ts` - Use shared module
- `src/background/service-worker.ts` - May need updates
- `src/shared/errors.ts` - May need StorageError if not present

## Test Criteria

1. **Unit Tests**:

   - Test all option getters return correct defaults
   - Test setters persist values correctly
   - Test change events fire properly
   - Test error handling for storage failures

2. **Integration Tests**:

   - Verify popup still shows/hides emojis correctly
   - Verify strict mode filtering works
   - Test options page saves correctly
   - Test cross-module option synchronization

3. **Manual Testing**:
   - Change options in options page
   - Verify popup reflects changes immediately
   - Test persistence across extension restart
   - Test sync across devices (if possible)

## Implementation Details

### Proposed Options Module Rewrite

```typescript
// src/shared/options.ts (complete rewrite)
import { Result, ResultAsync, ok, err } from 'neverthrow';
import { StorageError } from './errors';

// Option type definitions
export interface WormholeOptions {
  showEmojis: boolean;
  strictMode: boolean;
}

// Option metadata
interface OptionMetadata<K extends keyof WormholeOptions> {
  key: K;
  defaultValue: WormholeOptions[K];
  description: string;
}

// Option configurations
const OPTION_CONFIGS: { [K in keyof WormholeOptions]: OptionMetadata<K> } = {
  showEmojis: {
    key: 'showEmojis',
    defaultValue: true,
    description: 'Show emoji icons in service lists',
  },
  strictMode: {
    key: 'strictMode',
    defaultValue: false,
    description: 'Only show services that support the current content type',
  },
};

// Define defaults
const DEFAULT_OPTIONS: WormholeOptions = {
  showEmojis: true,
  strictMode: false,
};

// Get all options
export function getOptions(): ResultAsync<WormholeOptions, StorageError> {
  return ResultAsync.fromPromise(
    chrome.storage.sync.get(DEFAULT_OPTIONS),
    (error) => new StorageError('Failed to get options', error),
  ).map((result) => result as WormholeOptions);
}

// Get single option
export function getOption<K extends keyof WormholeOptions>(key: K): ResultAsync<WormholeOptions[K], StorageError> {
  return getOptions().map((options) => options[key]);
}

// Set option(s)
export function setOptions(options: Partial<WormholeOptions>): ResultAsync<void, StorageError> {
  return ResultAsync.fromPromise(
    chrome.storage.sync.set(options),
    (error) => new StorageError('Failed to set options', error),
  );
}

// Listen for changes
export function onOptionsChange(callback: (changes: Partial<WormholeOptions>) => void): void {
  chrome.storage.onChanged.addListener((changes, areaName) => {
    if (areaName === 'sync') {
      const optionChanges: Partial<WormholeOptions> = {};

      // Check for our option keys
      if ('showEmojis' in changes) {
        optionChanges.showEmojis = changes.showEmojis.newValue;
      }
      if ('strictMode' in changes) {
        optionChanges.strictMode = changes.strictMode.newValue;
      }

      if (Object.keys(optionChanges).length > 0) {
        callback(optionChanges);
      }
    }
  });
}

// Get default values
export function getDefaultOptions(): WormholeOptions {
  return { ...DEFAULT_OPTIONS };
}
```

## Success Metrics

- All option access goes through centralized module
- No duplicate option code remains
- Default values defined in one place
- Type safety maintained throughout
- All existing functionality preserved
- Tests pass for all option operations

## Risk Assessment

- **Low Risk**: Refactoring only, no behavior changes
- **Medium Impact**: Touches multiple files but maintains compatibility
- **High Benefit**: Cleaner, more maintainable code

## Migration Strategy

1. Rewrite the options module completely
2. Switch to individual-key storage pattern
3. Update all components to use the new API
4. Remove all duplicate code
5. Test thoroughly after updates

## Benefits

1. **Single Source of Truth**: All option definitions in one place
2. **Type Safety**: Full TypeScript support for options
3. **Maintainability**: Easy to add new options
4. **Consistency**: Same API across all modules
5. **Error Handling**: Centralized error handling with neverthrow
6. **Change Detection**: Built-in change event support

## Next Steps

1. Rewrite the options module with neverthrow
2. Switch to individual-key storage pattern
3. Add comprehensive tests
4. Update popup.ts to use shared module
5. Update options.ts to use shared module
6. Remove all duplicate code
7. Verify all functionality works correctly

## Key Decisions

1. **Complete Rewrite**: Replace the existing module entirely
2. **Storage Pattern**: Use individual keys (`showEmojis`, `strictMode`) matching current usage
3. **No Caching**: Remove complex caching since Chrome storage is already fast
4. **Full neverthrow**: Use Result types throughout with no console.warn fallbacks

## Implementation Notes

### Completed Tasks

- ✅ **Added StorageError to errors.ts** - New error type for storage operations
- ✅ **Rewrote src/shared/options.ts** - Complete rewrite with neverthrow integration
  - Switched from single-key to individual-key storage pattern
  - Added typed getter/setter functions with Result types
  - Implemented change event handling with WeakMap for proper listener cleanup
  - Added metadata access functions
  - Maintained legacy compatibility functions
- ✅ **Updated src/options/options.ts** - Uses shared module exclusively
  - Removed duplicate code
  - Added proper error handling
  - Implemented external change detection
- ✅ **Added comprehensive tests** - Full test coverage in tests/options.test.ts
  - Tests for all getter/setter functions
  - Change event testing
  - Error handling scenarios
  - Legacy compatibility testing
- ✅ **All validation passing** - Lint, typecheck, tests, and build all pass

### Technical Details

1. **WeakMap for Listener Management**: The options module wraps user callbacks in internal listeners. A WeakMap tracks the mapping to ensure proper cleanup when removeOptionsChangeListener is called.

2. **Type Safety**: All options are strongly typed through the WormholeOptions interface, with full TypeScript support for option keys and values.

3. **Error Handling**: All storage operations return ResultAsync with proper error types, forcing explicit error handling throughout the codebase.

4. **No Migration Needed**: Since we switched to individual-key storage (matching the existing usage pattern in popup/options), no data migration was required.
